atom,a - неспецифицированное неделимое.

s-expression,sexp,s - атом или набор атомов, дерево.

bin,b - последовательность бит. при выполнении может быть конвертировано в число
        (если все 8-битные части в диапазоне 0-9 и есть/нет префиксный -); или
        быть воспринято как имя переменной; если в начале списка - именем функции.
        в последних случаях, лишние биты (остаток от деления на 8) отбрасываются.
        
number,n - знаковое число неограниченного размера. может иметь статичную дробь -
         определяемую и расшираемую до большего всякий раз, когда происходитм мат
         операция.

* все функции обрабатывают свои аргументы слева направо, заходя в каждый список.
* если не оговорено обратное, функция исполняет все свои аргументы.
* если не оговорено обратное, все функции ожидают в конеце своих списков тел nil.




object,o - (неопр) объект - набор бит. слева - младшие биты, справа -
старшие. при преобразовании из текста младшие байты составляют младшую часть
битов, последовательно от младшего бита к старшему в каждом байте.

number,n - целое или дробное число.

* только файлы оперируют понятиями байт. считать из файла или записать в, можно
  только объект.


стандартные определения:

nil
  (set (quote nil) ())
t
  (set (quote t) (quote t))


реализованные функции:

(list s ...)

  (list) -> nil
  (list 's0 's1) -> (s0 s1)
  (list '(s0) 's1) -> ((s0) s1)
  (list '(s0) '(s1)) -> ((s0) (s1))

  формирование списка. возврат - этот список. если аргументов нет, то возврат -
  nil.


(append s ...)

  (append) -> nil
  (append 's0) -> s0
  (append '(a0 . a1)) -> (a0 . a1)
  (append '(a0) 'a1) -> (a0 . a1)
  (append '(s0) '(s1)) -> (s0 s1)

  объединить списки (оканчивающиеся с nil). не списком может быть последний (или
  единственный) аргумент. и он запишется как окончание списка, вместо nil. если
  аргументов нет, то возврат - nil.


(car s)
(cdr s)

  сперва аргумент выполянется. после сверяется с nil или sexp.


(quote !s)

  ничего не выполняется.


(cond (s ...) ...)

  тело ожидается быть строго списками, где первый элемент каждого из них
  определяет, после выполнения, дальнейшее направление выполнения. если его
  результат nil - то переход к следующему списку; иначе следующие элементы в
  списке выполняются пока не кончатся, возвратное значение соотвецтвует
  последнему. (!!!*4) всё остальное не выполняется и не проверяется на
  соотвецтвие строгой формы.


(defun !b (!b ...) !s ...)

  ничего не выполняется. тело состоит из обьекта - имен; списка обьектов -
  аргументов; и тело функции - подряд идущие любые конструкции (вплоть до
  никаких) которые выполняются последовательно, возвратное значение соотвецтвует
  последнему (если нет никаких - nil).

  (!!!*2) единственный способ указать отсуцтвие аргументов - это (). nil же, не
  может в такой схеме раскрыться. (!!!*0) аргументы могут быть числами - ну вот
  так оно получилось. (!!!*1) аргументы могут дублироваться - тогда они будут
  перекрывать друг друга (правый кроет левого).


(eval s)

  двойное выполнение аргумента.


(set b s)
(set b)

  изменить переменную. будет найдена первая по стеку в текущем пространстве, в
  глобальном пространсте, и переопределена. или же определена как локальная или
  глобальная (зависит от scope) в случае ненахода.

  первый аргумент должен быть объектом - именем переменной. возврат - значение.

  (!!!*3) имя может быть числом но получить потом по нему значение не получится
  (обьект проанализируется и пометится числом, и будет раскрываться сам в себя
  каждый раз).


(let ((!b s) ...) s ...)
(let ((!b)))

  в первом списке создаются переменные и затеняют аналоги, на время своей жизни
  - до выхода из этого let-scope. список состоит из списков с 2мя членами:
  обьектом - невыполняемым именем и выполняемым значением. следом подряд идут
  любые конструкции (вплоть до никаких) которые выполняются
  последовательно. возвратное значение соотвецтвует последнему (если нет никаких
  - nil).

  у переменной может быть не указано значение. в этом случае её значение - nil.


(load b)

  сперва аргумент выполянется. далее происходит попытка открыть и запустить файл
  с lisp-кодом. в случае успеха возвращается имя файла. в случае неуспеха
  выпадает ошибка.


(+ b ...) (- b ...) (* b ...) (/ b ...) (% b ...)

  сложение, вычитание, умножение, деление, остаток от деления.

  числа могут иметь фикс колл. знаков после запятой. перед операцией, меньший
  дополняется занками после запятой до большего.

  если (+)(-)(*) имеет один аргумент: возвращается тоже число.
  если (/)(%) имеет один аргумент: операция производится над 1.
  знак остатка зависит только от делимого - первого аргумента (или полож. при
  одном).


(= b ...) (< b ...) (> b ...) (=< b ...) (>= b ...)

  все равны; идут строго по возрастанию; строго по убыванию; по возрастанию; по
  убыванию.

  аргументы исполняются пока утверждение верно.
  возврат nil если не соотвецтвует шаблону, t - если соотвецтвует.

  если аргумент всего один, то результат - t.


(open b-path b-mode)

  открыть файл на чтение/запись с таким методом.
  
  mode (r or R, w or W):
    r открыть на чтение
    w открыть на запись
    c создать если файла нет
    b открыть как битовый файл
    (не реализованно:)
    -R открыть на чтение. с правами на расширение
    -W открыть на запись. с правами на расширение
    -s строго соответствуя размеру файла

  возврат - дескриптор файла (число). или nil в случае неудачи.


(read n-fd n-size)

  прочитать из файла столько данных. последовательно, от младшего байта к
  старшему, в порядке, от младшего бита к старшему в каждом байте.

  возврат - данные, размером <= size. или, если данных нет, возврат - nil.

(write n-fd b-data)

  записать в файл.

  возврат - число записанных бит данных.





не реализовано:

(bitsof b-data)

  размер данных в битах.


(resize n-mode b-data n-bits)

  n-mode
    nil         по умолчанию
    RS_TOLEFT   расширение/сужение влево
    RS_TORIGHT  расширение/сужение вправо (по умолчанию)
    RS_FILLZERO новые биты в 0 (по умолчанию)
    RS_FILLONE  новые биты в 1


(bin-to-number bin)

  перевести из данных в число. первый бит - меньший по значению.

  для распаковки знаковых чисел, необходимо (two’s complement):
  (- n (* (pow 2 bits) (/ n (pow 2 (- bits 1)))))

-  для распаковки дроби, необходимо (???? !!!):
-  (* n (pow 10 (- 0 f)))


(number-to-bin number)

  перевести из числа в данные. перевести из данных в число. первый бит - меньший
  по значению. дробь записывается как если бы это была часть
  целого. отрицательный знак отбрасывается.

  для запаковки знаковых чисел, необходимо (two’s complement):
  (%  (- (pow 2 bits) n) (pow 2 bits))


-  bits расширяется и сужается от младшего бита к старшему. если bits == 0,
-  возвратное значение будет иметь столько бит, сколько нужно чтобы поместилось
-  всё число.


(pow n ...)
(not)

(xor)
(or)
(and)


(close n-fd)

(parse b)


(index bin n-size n-index)

(str-to-number bin)
(number-to-str number)



(virtual-file data cnv) => fd

  cnv
    l младшие биты в младших битах байта
    m младшие биты в старших битах байта
    i младшие биты формирующие байт в начале
    d младшие биты формирующие байт в конце

(seek fd)
(tell fd)

(file-pmode mode)
(file-bmode mode)

  mode (io or do, lsf or msf):
    i increase oriented
    d decrease oriented
    l least significant bit of byte first
    m most significant bit of byte first


;;
"" строки (если две строки впритык, они соеденяются в одно)
# соеденитель (удаляет все whitespace между атомами)
(eq s s)
(port o ...) - способ связи с внешним кодом. первый аргемент - номер в таблице внешних функций. остальные - аргументы этой функции, каждый должен быть объектом (????? потому что так проще отслеживать). а нужно ли это вообще?
' сокращение для quote
(cons s s)

(^ o ...)
(/= o ...) нужно городить отдельную функцию и возможно, переопределять snode'ы выстраивая их в дерево для пущего поиска.

(null s)
(listp s)
(atom s)


*default-pathname-defaults*
*load-pathname*
*load-truename*
(merge-pathnames)


(map s s)

на подумать:

(require atom)
(provide atom)
(eq s s)
(error)
(apropos "")
(makunbound 'foo)
